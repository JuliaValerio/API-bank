{"ast":null,"code":"import { __assign, __rest, __extends } from 'tslib';\nimport { Children, createContext, useContext, useRef, useReducer, useCallback, useEffect, useMemo, createElement, Component } from 'react';\nimport isEqual from 'react-fast-compare';\nimport deepmerge from 'deepmerge';\nimport cloneDeep from 'lodash-es/cloneDeep';\nimport toPath from 'lodash-es/toPath';\nimport warning from 'tiny-warning';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nfunction getIn(obj, key, def, p) {\n  if (p === void 0) {\n    p = 0;\n  }\n\n  var path = toPath(key);\n\n  while (obj && p < path.length) {\n    obj = obj[path[p++]];\n  }\n\n  return obj === undefined ? def : obj;\n}\n\nfunction setIn(obj, path, value) {\n  var res = {};\n  var resVal = res;\n  var i = 0;\n  var pathArray = toPath(path);\n\n  for (; i < pathArray.length - 1; i++) {\n    var currentPath = pathArray[i];\n    var currentObj = getIn(obj, pathArray.slice(0, i + 1));\n\n    if (resVal[currentPath]) {\n      resVal = resVal[currentPath];\n    } else if (currentObj) {\n      resVal = resVal[currentPath] = cloneDeep(currentObj);\n    } else {\n      var nextPath = pathArray[i + 1];\n      resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};\n    }\n  }\n\n  if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {\n    return obj;\n  }\n\n  if (value === undefined) {\n    delete resVal[pathArray[i]];\n  } else {\n    resVal[pathArray[i]] = value;\n  }\n\n  var result = __assign({}, obj, res);\n\n  if (i === 0 && value === undefined) {\n    delete result[pathArray[i]];\n  }\n\n  return result;\n}\n\nfunction setNestedObjectValues(object, value, visited, response) {\n  if (visited === void 0) {\n    visited = new WeakMap();\n  }\n\n  if (response === void 0) {\n    response = {};\n  }\n\n  for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {\n    var k = _a[_i];\n    var val = object[k];\n\n    if (isObject(val)) {\n      if (!visited.get(val)) {\n        visited.set(val, true);\n        response[k] = Array.isArray(val) ? [] : {};\n        setNestedObjectValues(val, value, visited, response[k]);\n      }\n    } else {\n      response[k] = value;\n    }\n  }\n\n  return response;\n}\n\nvar isFunction = function (obj) {\n  return typeof obj === 'function';\n};\n\nvar isObject = function (obj) {\n  return obj !== null && typeof obj === 'object';\n};\n\nvar isInteger = function (obj) {\n  return String(Math.floor(Number(obj))) === obj;\n};\n\nvar isString = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object String]';\n};\n\nvar isNaN$1 = function (obj) {\n  return obj !== obj;\n};\n\nvar isEmptyChildren = function (children) {\n  return Children.count(children) === 0;\n};\n\nvar isPromise = function (value) {\n  return isObject(value) && isFunction(value.then);\n};\n\nfunction getActiveElement(doc) {\n  doc = doc || (typeof document !== 'undefined' ? document : undefined);\n\n  if (typeof doc === 'undefined') {\n    return null;\n  }\n\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\n\nfunction makeCancelable(promise) {\n  var hasCanceled = false;\n  var wrappedPromise = new Promise(function (resolve, reject) {\n    promise.then(function (val) {\n      return hasCanceled ? reject({\n        isCanceled: true\n      }) : resolve(val);\n    }, function (error) {\n      return hasCanceled ? reject({\n        isCanceled: true\n      }) : reject(error);\n    });\n  });\n  return [wrappedPromise, function cancel() {\n    hasCanceled = true;\n  }];\n}\n\nvar PrivateFormikContext =\n/*#__PURE__*/\ncreateContext({});\nvar FormikProvider = PrivateFormikContext.Provider;\nvar FormikConsumer = PrivateFormikContext.Consumer;\n\nfunction useFormikContext() {\n  return useContext(PrivateFormikContext);\n}\n\nfunction formikReducer(state, msg) {\n  switch (msg.type) {\n    case 'SET_VALUES':\n      return __assign({}, state, {\n        values: msg.payload\n      });\n\n    case 'SET_TOUCHED':\n      return __assign({}, state, {\n        touched: msg.payload\n      });\n\n    case 'SET_ERRORS':\n      return __assign({}, state, {\n        errors: msg.payload\n      });\n\n    case 'SET_STATUS':\n      return __assign({}, state, {\n        status: msg.payload\n      });\n\n    case 'SET_ISSUBMITTING':\n      return __assign({}, state, {\n        isSubmitting: msg.payload\n      });\n\n    case 'SET_ISVALIDATING':\n      return __assign({}, state, {\n        isValidating: msg.payload\n      });\n\n    case 'SET_FIELD_VALUE':\n      return __assign({}, state, {\n        values: setIn(state.values, msg.payload.field, msg.payload.value)\n      });\n\n    case 'SET_FIELD_TOUCHED':\n      return __assign({}, state, {\n        touched: setIn(state.touched, msg.payload.field, msg.payload.value)\n      });\n\n    case 'SET_FIELD_ERROR':\n      return __assign({}, state, {\n        errors: setIn(state.errors, msg.payload.field, msg.payload.value)\n      });\n\n    case 'RESET_FORM':\n    case 'SET_FORMIK_STATE':\n      return __assign({}, state, msg.payload);\n\n    case 'SUBMIT_ATTEMPT':\n      return __assign({}, state, {\n        touched: setNestedObjectValues(state.values, true),\n        isSubmitting: true,\n        submitCount: state.submitCount + 1\n      });\n\n    case 'SUBMIT_FAILURE':\n      return __assign({}, state, {\n        isSubmitting: false\n      });\n\n    case 'SUBMIT_SUCCESS':\n      return __assign({}, state, {\n        isSubmitting: false\n      });\n\n    default:\n      return state;\n  }\n}\n\nfunction useFormik(_a) {\n  var _b = _a.validateOnChange,\n      validateOnChange = _b === void 0 ? true : _b,\n      _c = _a.validateOnBlur,\n      validateOnBlur = _c === void 0 ? true : _c,\n      _d = _a.isInitialValid,\n      isInitialValid = _d === void 0 ? false : _d,\n      rest = __rest(_a, [\"validateOnChange\", \"validateOnBlur\", \"isInitialValid\"]);\n\n  var props = __assign({\n    validateOnChange: validateOnChange,\n    validateOnBlur: validateOnBlur,\n    isInitialValid: isInitialValid\n  }, rest);\n\n  var initialValues = useRef(props.initialValues);\n  var isMounted = useRef(false);\n  var fields = useRef({});\n\n  var _e = useReducer(formikReducer, {\n    values: props.initialValues,\n    errors: {},\n    touched: {},\n    isSubmitting: false,\n    isValidating: false,\n    submitCount: 0\n  }),\n      state = _e[0],\n      dispatch = _e[1];\n\n  var runValidationAsEffect = useCallback(function () {\n    var _a = makeCancelable(validateForm(state.values)),\n        validate = _a[0],\n        cancel = _a[1];\n\n    validate.then(function (x) {\n      return x;\n    }).catch(function (x) {\n      return x;\n    });\n    return cancel;\n  }, [state.values]);\n  useEffect(function () {\n    if (!!validateOnChange && !state.isSubmitting && isMounted.current) {\n      return runValidationAsEffect();\n    }\n\n    return;\n  }, [state.values]);\n  useEffect(function () {\n    if (!!validateOnBlur && !state.isSubmitting && isMounted.current) {\n      return runValidationAsEffect();\n    }\n\n    return;\n  }, [state.touched]);\n  useEffect(function () {\n    isMounted.current = true;\n    return function () {\n      isMounted.current = false;\n    };\n  }, []);\n  var imperativeMethods = {\n    resetForm: resetForm,\n    submitForm: submitForm,\n    validateForm: validateForm,\n    validateField: validateField,\n    setErrors: setErrors,\n    setFieldError: setFieldError,\n    setFieldTouched: setFieldTouched,\n    setFieldValue: setFieldValue,\n    setStatus: setStatus,\n    setSubmitting: setSubmitting,\n    setTouched: setTouched,\n    setValues: setValues,\n    setFormikState: setFormikState\n  };\n\n  function registerField(name, _a) {\n    var validate = _a.validate;\n\n    if (fields.current !== null) {\n      fields.current[name] = {\n        validate: validate\n      };\n    }\n  }\n\n  function unregisterField(name) {\n    if (fields.current !== null) {\n      delete fields.current[name];\n    }\n  }\n\n  function handleBlur(eventOrString) {\n    if (isString(eventOrString)) {\n      return function (event) {\n        return executeBlur(event, eventOrString);\n      };\n    } else {\n      executeBlur(eventOrString);\n    }\n\n    function executeBlur(e, path) {\n      if (e.persist) {\n        e.persist();\n      }\n\n      var _a = e.target,\n          name = _a.name,\n          id = _a.id,\n          outerHTML = _a.outerHTML;\n      var field = path ? path : name ? name : id;\n\n      if (!field && process.env.NODE_ENV !== 'production') {\n        warnAboutMissingIdentifier({\n          htmlContent: outerHTML,\n          documentationAnchorLink: 'handleblur-e-any--void',\n          handlerName: 'handleBlur'\n        });\n      }\n\n      dispatch({\n        type: 'SET_FIELD_TOUCHED',\n        payload: {\n          field: field,\n          value: true\n        }\n      });\n    }\n  }\n\n  function handleChange(eventOrPath) {\n    if (isString(eventOrPath)) {\n      return function (event) {\n        return executeChange(event, eventOrPath);\n      };\n    } else {\n      executeChange(eventOrPath);\n    }\n\n    function executeChange(eventOrTextValue, maybePath) {\n      var field = maybePath;\n      var val = eventOrTextValue;\n      var parsed;\n\n      if (!isString(eventOrTextValue)) {\n        if (eventOrTextValue.persist) {\n          eventOrTextValue.persist();\n        }\n\n        var _a = eventOrTextValue.target,\n            type = _a.type,\n            name_1 = _a.name,\n            id = _a.id,\n            value = _a.value,\n            checked = _a.checked,\n            outerHTML = _a.outerHTML;\n        field = maybePath ? maybePath : name_1 ? name_1 : id;\n\n        if (!field && process.env.NODE_ENV !== 'production') {\n          warnAboutMissingIdentifier({\n            htmlContent: outerHTML,\n            documentationAnchorLink: 'handlechange-e-reactchangeeventany--void',\n            handlerName: 'handleChange'\n          });\n        }\n\n        val = /number|range/.test(type) ? (parsed = parseFloat(value), isNaN(parsed) ? '' : parsed) : /checkbox/.test(type) ? checked : value;\n      }\n\n      if (field) {\n        dispatch({\n          type: 'SET_FIELD_VALUE',\n          payload: {\n            field: field,\n            value: val\n          }\n        });\n      }\n    }\n  }\n\n  function handleReset() {\n    if (props.onReset) {\n      var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);\n\n      if (isPromise(maybePromisedOnReset)) {\n        maybePromisedOnReset.then(resetForm);\n      } else {\n        resetForm();\n      }\n    } else {\n      resetForm();\n    }\n  }\n\n  function handleSubmit(e) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    if (process.env.NODE_ENV !== 'production' && typeof document !== 'undefined') {\n      var activeElement = getActiveElement();\n\n      if (activeElement !== null && activeElement instanceof HTMLButtonElement) {\n        process.env.NODE_ENV !== \"production\" ? warning(activeElement.attributes && activeElement.attributes.getNamedItem('type'), 'You submitted a Formik form using a button with an unspecified `type` attribute.  Most browsers default button elements to `type=\"submit\"`. If this is not a submit button, please add `type=\"button\"`.') : void 0;\n      }\n    }\n\n    submitForm();\n  }\n\n  function executeSubmit() {\n    return props.onSubmit(state.values, imperativeMethods);\n  }\n\n  function resetForm(nextValues) {\n    var values = nextValues ? nextValues : initialValues.current !== null ? initialValues.current : props.initialValues;\n    initialValues.current = values;\n    dispatch({\n      type: 'RESET_FORM',\n      payload: {\n        isSubmitting: false,\n        errors: {},\n        touched: {},\n        status: undefined,\n        values: values,\n        isValidating: false,\n        submitCount: 0\n      }\n    });\n  }\n\n  function setTouched(touched) {\n    dispatch({\n      type: 'SET_TOUCHED',\n      payload: touched\n    });\n  }\n\n  function setErrors(errors) {\n    dispatch({\n      type: 'SET_ERRORS',\n      payload: errors\n    });\n  }\n\n  function setValues(values) {\n    dispatch({\n      type: 'SET_VALUES',\n      payload: values\n    });\n  }\n\n  function setFieldError(field, value) {\n    dispatch({\n      type: 'SET_FIELD_ERROR',\n      payload: {\n        field: field,\n        value: value\n      }\n    });\n  }\n\n  function setFieldValue(field, value) {\n    dispatch({\n      type: 'SET_FIELD_VALUE',\n      payload: {\n        field: field,\n        value: value\n      }\n    });\n  }\n\n  function setFieldTouched(field, touched) {\n    if (touched === void 0) {\n      touched = true;\n    }\n\n    dispatch({\n      type: 'SET_FIELD_TOUCHED',\n      payload: {\n        field: field,\n        value: touched\n      }\n    });\n  }\n\n  function validateField(name) {\n    if (fields.current !== null && fields.current[name] && fields.current[name].validate && isFunction(fields.current[name].validate)) {\n      var value = getIn(state.values, name);\n      var maybePromise = fields.current[name].validate(value);\n\n      if (isPromise(maybePromise)) {\n        dispatch({\n          type: 'SET_ISVALIDATING',\n          payload: true\n        });\n        return maybePromise.then(function (x) {\n          return x;\n        }, function (e) {\n          return e;\n        }).then(function (error) {\n          dispatch({\n            type: 'SET_FIELD_ERROR',\n            payload: {\n              field: name,\n              value: error\n            }\n          });\n          dispatch({\n            type: 'SET_ISVALIDATING',\n            payload: false\n          });\n        });\n      } else {\n        dispatch({\n          type: 'SET_FIELD_ERROR',\n          payload: {\n            field: name,\n            value: maybePromise\n          }\n        });\n        return Promise.resolve(maybePromise);\n      }\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  function runValidateHandler(values, field) {\n    return new Promise(function (resolve) {\n      var maybePromisedErrors = props.validate(values, field);\n\n      if (maybePromisedErrors === undefined) {\n        resolve({});\n      } else if (isPromise(maybePromisedErrors)) {\n        maybePromisedErrors.then(function () {\n          resolve({});\n        }, function (errors) {\n          resolve(errors);\n        });\n      } else {\n        resolve(maybePromisedErrors);\n      }\n    });\n  }\n\n  function runValidationSchema(values, field) {\n    return new Promise(function (resolve) {\n      var validationSchema = props.validationSchema;\n      var schema = isFunction(validationSchema) ? validationSchema(field) : validationSchema;\n      var promise = field && schema.validateAt ? schema.validateAt(field, values) : validateYupSchema(values, schema);\n      promise.then(function () {\n        resolve({});\n      }, function (err) {\n        resolve(yupToFormErrors(err));\n      });\n    });\n  }\n\n  function runSingleFieldLevelValidation(field, value) {\n    return new Promise(function (resolve) {\n      return resolve(fields.current[field].validate(value));\n    }).then(function (x) {\n      return x;\n    }, function (e) {\n      return e;\n    });\n  }\n\n  function runFieldLevelValidations(values) {\n    if (fields.current === null) {\n      return Promise.resolve({});\n    }\n\n    var fieldKeysWithValidation = Object.keys(fields.current).filter(function (f) {\n      return fields.current !== null && fields.current[f] && fields.current[f].validate && isFunction(fields.current[f].validate);\n    });\n    var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function (f) {\n      return runSingleFieldLevelValidation(f, getIn(values, f));\n    }) : [Promise.resolve('DO_NOT_DELETE_YOU_WILL_BE_FIRED')];\n    return Promise.all(fieldValidations).then(function (fieldErrorsList) {\n      return fieldErrorsList.reduce(function (prev, curr, index) {\n        if (curr === 'DO_NOT_DELETE_YOU_WILL_BE_FIRED') {\n          return prev;\n        }\n\n        if (!!curr) {\n          prev = setIn(prev, fieldKeysWithValidation[index], curr);\n        }\n\n        return prev;\n      }, {});\n    });\n  }\n\n  function validateForm(values) {\n    if (values === void 0) {\n      values = state.values;\n    }\n\n    if (props.validationSchema || props.validate || fields.current && Object.keys(fields.current).filter(function (key) {\n      return !!fields.current[key].validate;\n    }).length > 0) {\n      dispatch({\n        type: 'SET_ISVALIDATING',\n        payload: true\n      });\n      return Promise.all([runFieldLevelValidations(values), props.validationSchema ? runValidationSchema(values) : {}, props.validate ? runValidateHandler(values) : {}]).then(function (_a) {\n        var fieldErrors = _a[0],\n            schemaErrors = _a[1],\n            validateErrors = _a[2];\n        var combinedErrors = deepmerge.all([fieldErrors, schemaErrors, validateErrors], {\n          arrayMerge: arrayMerge\n        });\n\n        if (!isEqual(state.errors, combinedErrors)) {\n          dispatch({\n            type: 'SET_ERRORS',\n            payload: combinedErrors\n          });\n        }\n\n        dispatch({\n          type: 'SET_ISVALIDATING',\n          payload: false\n        });\n        return combinedErrors;\n      });\n    } else {\n      return Promise.resolve({});\n    }\n  }\n\n  function setFormikState(stateOrCb) {\n    if (isFunction(stateOrCb)) {\n      dispatch({\n        type: 'SET_FORMIK_STATE',\n        payload: stateOrCb(state)\n      });\n    } else {\n      dispatch({\n        type: 'SET_FORMIK_STATE',\n        payload: stateOrCb\n      });\n    }\n  }\n\n  function setStatus(status) {\n    dispatch({\n      type: 'SET_STATUS',\n      payload: status\n    });\n  }\n\n  function setSubmitting(isSubmitting) {\n    dispatch({\n      type: 'SET_ISSUBMITTING',\n      payload: isSubmitting\n    });\n  }\n\n  function submitForm() {\n    dispatch({\n      type: 'SUBMIT_ATTEMPT'\n    });\n    return validateForm().then(function (combinedErrors) {\n      var isActuallyValid = Object.keys(combinedErrors).length === 0;\n\n      if (isActuallyValid) {\n        Promise.resolve(executeSubmit()).then(function () {\n          if (isMounted.current) {\n            dispatch({\n              type: 'SUBMIT_SUCCESS'\n            });\n          }\n        }).catch(function (_errors) {\n          if (isMounted.current) {\n            dispatch({\n              type: 'SUBMIT_FAILURE'\n            });\n          }\n        });\n      } else if (isMounted.current) {\n        dispatch({\n          type: 'SUBMIT_FAILURE'\n        });\n      }\n    });\n  }\n\n  function getFieldProps(name, type) {\n    var field = {\n      name: name,\n      value: type && (type === 'radio' || type === 'checkbox') ? undefined : getIn(state.values, name),\n      onChange: handleChange,\n      onBlur: handleBlur\n    };\n    return [field, getFieldMeta(name)];\n  }\n\n  function getFieldMeta(name) {\n    return {\n      value: getIn(state.values, name),\n      error: getIn(state.errors, name),\n      touch: getIn(state.touched, name),\n      initialValue: getIn(initialValues.current, name)\n    };\n  }\n\n  var dirty = useMemo(function () {\n    return !isEqual(initialValues.current, state.values);\n  }, [initialValues.current, state.values]);\n  var isValid = useMemo(function () {\n    return dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && isFunction(isInitialValid) ? isInitialValid(props) : isInitialValid;\n  }, [state.errors, dirty, isInitialValid]);\n\n  var ctx = __assign({}, state, {\n    initialValues: initialValues.current || props.initialValues,\n    handleBlur: handleBlur,\n    handleChange: handleChange,\n    handleReset: handleReset,\n    handleSubmit: handleSubmit,\n    resetForm: resetForm,\n    setErrors: setErrors,\n    setFormikState: setFormikState,\n    setFieldTouched: setFieldTouched,\n    setFieldValue: setFieldValue,\n    setFieldError: setFieldError,\n    setStatus: setStatus,\n    setSubmitting: setSubmitting,\n    setTouched: setTouched,\n    setValues: setValues,\n    submitForm: submitForm,\n    validateForm: validateForm,\n    validateField: validateField,\n    isValid: isValid,\n    dirty: dirty,\n    unregisterField: unregisterField,\n    registerField: registerField,\n    getFieldProps: getFieldProps,\n    validateOnBlur: validateOnBlur,\n    validateOnChange: validateOnChange\n  });\n\n  return ctx;\n}\n\nfunction Formik(props) {\n  var formikbag = useFormik(props);\n  var component = props.component,\n      children = props.children,\n      render = props.render;\n  return createElement(FormikProvider, {\n    value: formikbag\n  }, component ? createElement(component, formikbag) : render ? render(formikbag) : children ? isFunction(children) ? children(formikbag) : !isEmptyChildren(children) ? Children.only(children) : null : null);\n}\n\nfunction warnAboutMissingIdentifier(_a) {\n  var htmlContent = _a.htmlContent,\n      documentationAnchorLink = _a.documentationAnchorLink,\n      handlerName = _a.handlerName;\n  console.warn(\"Warning: Formik called `\" + handlerName + \"`, but you forgot to pass an `id` or `name` attribute to your input:\\n    \" + htmlContent + \"\\n    Formik cannot determine which value to update. For more info see https://github.com/jaredpalmer/formik#\" + documentationAnchorLink + \"\\n  \");\n}\n\nfunction yupToFormErrors(yupError) {\n  var errors = {};\n\n  if (yupError.inner.length === 0) {\n    return setIn(errors, yupError.path, yupError.message);\n  }\n\n  for (var _i = 0, _a = yupError.inner; _i < _a.length; _i++) {\n    var err = _a[_i];\n\n    if (!errors[err.path]) {\n      errors = setIn(errors, err.path, err.message);\n    }\n  }\n\n  return errors;\n}\n\nfunction validateYupSchema(values, schema, sync, context) {\n  if (sync === void 0) {\n    sync = false;\n  }\n\n  if (context === void 0) {\n    context = {};\n  }\n\n  var validateData = {};\n\n  for (var k in values) {\n    if (values.hasOwnProperty(k)) {\n      var key = String(k);\n      validateData[key] = values[key] !== '' ? values[key] : undefined;\n    }\n  }\n\n  return schema[sync ? 'validateSync' : 'validate'](validateData, {\n    abortEarly: false,\n    context: context\n  });\n}\n\nfunction arrayMerge(target, source, options) {\n  var destination = target.slice();\n  source.forEach(function (e, i) {\n    if (typeof destination[i] === 'undefined') {\n      var cloneRequested = options.clone !== false;\n      var shouldClone = cloneRequested && options.isMergeableObject(e);\n      destination[i] = shouldClone ? deepmerge(Array.isArray(e) ? [] : {}, e, options) : e;\n    } else if (options.isMergeableObject(e)) {\n      destination[i] = deepmerge(target[i], e, options);\n    } else if (target.indexOf(e) === -1) {\n      destination.push(e);\n    }\n  });\n  return destination;\n}\n\nfunction useField(name, type) {\n  var formik = useFormikContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== \"production\" ? warning(formik, 'useField() / <Field /> must be used underneath a <Formik> component or withFormik() higher order component') : void 0;\n  }\n\n  return formik.getFieldProps(name, type);\n}\n\nfunction Field(_a) {\n  var validate = _a.validate,\n      name = _a.name,\n      render = _a.render,\n      children = _a.children,\n      _b = _a.component,\n      component = _b === void 0 ? 'input' : _b,\n      props = __rest(_a, [\"validate\", \"name\", \"render\", \"children\", \"component\"]);\n\n  var _c = useFormikContext(),\n      _validate = _c.validate,\n      _validationSchema = _c.validationSchema,\n      formik = __rest(_c, [\"validate\", \"validationSchema\"]);\n\n  process.env.NODE_ENV !== \"production\" ? warning(component && render, 'You should not use <Field component> and <Field render> in the same <Field> component; <Field component> will be ignored') : void 0;\n  process.env.NODE_ENV !== \"production\" ? warning(component && children && isFunction(children), 'You should not use <Field component> and <Field children> as a function in the same <Field> component; <Field component> will be ignored.') : void 0;\n  process.env.NODE_ENV !== \"production\" ? warning(render && children && !isEmptyChildren(children), 'You should not use <Field render> and <Field children> in the same <Field> component; <Field children> will be ignored') : void 0;\n  useEffect(function () {\n    formik.registerField(name, {\n      validate: validate\n    });\n    return function () {\n      formik.unregisterField(name);\n    };\n  }, [name, validate]);\n  var field = formik.getFieldProps(name, props.type)[0];\n  var bag = {\n    field: field,\n    form: formik\n  };\n\n  if (render) {\n    return render(bag);\n  }\n\n  if (isFunction(children)) {\n    return children(bag);\n  }\n\n  if (typeof component === 'string') {\n    var innerRef = props.innerRef,\n        rest = __rest(props, [\"innerRef\"]);\n\n    return createElement(component, __assign({\n      ref: innerRef\n    }, field, rest, {\n      children: children\n    }));\n  }\n\n  return createElement(component, __assign({}, bag, props, {\n    children: children\n  }));\n}\n\nvar FastField = Field;\n\nfunction Form(props) {\n  var _a = useFormikContext(),\n      handleReset = _a.handleReset,\n      handleSubmit = _a.handleSubmit;\n\n  return createElement(\"form\", __assign({\n    onSubmit: handleSubmit,\n    onReset: handleReset\n  }, props));\n}\n\nForm.displayName = 'Form';\n\nfunction withFormik(_a) {\n  var _b = _a.mapPropsToValues,\n      mapPropsToValues = _b === void 0 ? function (vanillaProps) {\n    var val = {};\n\n    for (var k in vanillaProps) {\n      if (vanillaProps.hasOwnProperty(k) && typeof vanillaProps[k] !== 'function') {\n        val[k] = vanillaProps[k];\n      }\n    }\n\n    return val;\n  } : _b,\n      config = __rest(_a, [\"mapPropsToValues\"]);\n\n  return function createFormik(Component$$1) {\n    var componentDisplayName = Component$$1.displayName || Component$$1.name || Component$$1.constructor && Component$$1.constructor.name || 'Component';\n\n    var C = function (_super) {\n      __extends(C, _super);\n\n      function C() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.validate = function (values) {\n          return config.validate(values, _this.props);\n        };\n\n        _this.validationSchema = function () {\n          return isFunction(config.validationSchema) ? config.validationSchema(_this.props) : config.validationSchema;\n        };\n\n        _this.handleSubmit = function (values, actions) {\n          return config.handleSubmit(values, __assign({}, actions, {\n            props: _this.props\n          }));\n        };\n\n        _this.renderFormComponent = function (formikProps) {\n          return createElement(Component$$1, __assign({}, _this.props, formikProps));\n        };\n\n        return _this;\n      }\n\n      C.prototype.render = function () {\n        var _a = this.props,\n            children = _a.children,\n            props = __rest(_a, [\"children\"]);\n\n        return createElement(Formik, __assign({}, props, config, {\n          validate: config.validate && this.validate,\n          validationSchema: config.validationSchema && this.validationSchema,\n          initialValues: mapPropsToValues(this.props),\n          initialStatus: config.mapPropsToStatus && config.mapPropsToStatus(this.props),\n          onSubmit: this.handleSubmit,\n          render: this.renderFormComponent\n        }));\n      };\n\n      C.displayName = \"WithFormik(\" + componentDisplayName + \")\";\n      return C;\n    }(Component);\n\n    return hoistNonReactStatics(C, Component$$1);\n  };\n}\n\nfunction connect(Comp) {\n  var C = function (props) {\n    return createElement(FormikConsumer, null, function (formik) {\n      return createElement(Comp, __assign({}, props, {\n        formik: formik\n      }));\n    });\n  };\n\n  var componentDisplayName = Comp.displayName || Comp.name || Comp.constructor && Comp.constructor.name || 'Component';\n  C.WrappedComponent = Comp;\n  C.displayName = \"FormikConnect(\" + componentDisplayName + \")\";\n  return hoistNonReactStatics(C, Comp);\n}\n\nvar move = function (array, from, to) {\n  var copy = (array || []).slice();\n  var value = copy[from];\n  copy.splice(from, 1);\n  copy.splice(to, 0, value);\n  return copy;\n};\n\nvar swap = function (array, indexA, indexB) {\n  var copy = (array || []).slice();\n  var a = copy[indexA];\n  copy[indexA] = copy[indexB];\n  copy[indexB] = a;\n  return copy;\n};\n\nvar insert = function (array, index, value) {\n  var copy = (array || []).slice();\n  copy.splice(index, 0, value);\n  return copy;\n};\n\nvar replace = function (array, index, value) {\n  var copy = (array || []).slice();\n  copy[index] = value;\n  return copy;\n};\n\nvar FieldArrayInner =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(FieldArrayInner, _super);\n\n  function FieldArrayInner(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.updateArrayField = function (fn, alterTouched, alterErrors) {\n      var _a = _this.props,\n          name = _a.name,\n          validateOnChange = _a.validateOnChange,\n          _b = _a.formik,\n          setFormikState = _b.setFormikState,\n          validateForm = _b.validateForm;\n      setFormikState(function (prevState) {\n        var updateErrors = typeof alterErrors === 'function' ? alterErrors : fn;\n        var updateTouched = typeof alterTouched === 'function' ? alterTouched : fn;\n        return __assign({}, prevState, {\n          values: setIn(prevState.values, name, fn(getIn(prevState.values, name))),\n          errors: alterErrors ? setIn(prevState.errors, name, updateErrors(getIn(prevState.errors, name))) : prevState.errors,\n          touched: alterTouched ? setIn(prevState.touched, name, updateTouched(getIn(prevState.touched, name))) : prevState.touched\n        });\n      }, function () {\n        if (validateOnChange) {\n          validateForm();\n        }\n      });\n    };\n\n    _this.push = function (value) {\n      return _this.updateArrayField(function (array) {\n        return (array || []).concat([cloneDeep(value)]);\n      }, false, false);\n    };\n\n    _this.handlePush = function (value) {\n      return function () {\n        return _this.push(value);\n      };\n    };\n\n    _this.swap = function (indexA, indexB) {\n      return _this.updateArrayField(function (array) {\n        return swap(array, indexA, indexB);\n      }, true, true);\n    };\n\n    _this.handleSwap = function (indexA, indexB) {\n      return function () {\n        return _this.swap(indexA, indexB);\n      };\n    };\n\n    _this.move = function (from, to) {\n      return _this.updateArrayField(function (array) {\n        return move(array, from, to);\n      }, true, true);\n    };\n\n    _this.handleMove = function (from, to) {\n      return function () {\n        return _this.move(from, to);\n      };\n    };\n\n    _this.insert = function (index, value) {\n      return _this.updateArrayField(function (array) {\n        return insert(array, index, value);\n      }, function (array) {\n        return insert(array, index, null);\n      }, function (array) {\n        return insert(array, index, null);\n      });\n    };\n\n    _this.handleInsert = function (index, value) {\n      return function () {\n        return _this.insert(index, value);\n      };\n    };\n\n    _this.replace = function (index, value) {\n      return _this.updateArrayField(function (array) {\n        return replace(array, index, value);\n      }, false, false);\n    };\n\n    _this.handleReplace = function (index, value) {\n      return function () {\n        return _this.replace(index, value);\n      };\n    };\n\n    _this.unshift = function (value) {\n      var length = -1;\n\n      _this.updateArrayField(function (array) {\n        var arr = array ? [value].concat(array) : [value];\n\n        if (length < 0) {\n          length = arr.length;\n        }\n\n        return arr;\n      }, function (array) {\n        var arr = array ? [null].concat(array) : [null];\n\n        if (length < 0) {\n          length = arr.length;\n        }\n\n        return arr;\n      }, function (array) {\n        var arr = array ? [null].concat(array) : [null];\n\n        if (length < 0) {\n          length = arr.length;\n        }\n\n        return arr;\n      });\n\n      return length;\n    };\n\n    _this.handleUnshift = function (value) {\n      return function () {\n        return _this.unshift(value);\n      };\n    };\n\n    _this.handleRemove = function (index) {\n      return function () {\n        return _this.remove(index);\n      };\n    };\n\n    _this.handlePop = function () {\n      return function () {\n        return _this.pop();\n      };\n    };\n\n    _this.remove = _this.remove.bind(_this);\n    _this.pop = _this.pop.bind(_this);\n    return _this;\n  }\n\n  FieldArrayInner.prototype.remove = function (index) {\n    var result;\n    this.updateArrayField(function (array) {\n      var copy = array ? array.slice() : [];\n\n      if (!result) {\n        result = copy[index];\n      }\n\n      if (isFunction(copy.splice)) {\n        copy.splice(index, 1);\n      }\n\n      return copy;\n    }, true, true);\n    return result;\n  };\n\n  FieldArrayInner.prototype.pop = function () {\n    var result;\n    this.updateArrayField(function (array) {\n      var tmp = array;\n\n      if (!result) {\n        result = tmp && tmp.pop && tmp.pop();\n      }\n\n      return tmp;\n    }, true, true);\n    return result;\n  };\n\n  FieldArrayInner.prototype.render = function () {\n    var arrayHelpers = {\n      push: this.push,\n      pop: this.pop,\n      swap: this.swap,\n      move: this.move,\n      insert: this.insert,\n      replace: this.replace,\n      unshift: this.unshift,\n      remove: this.remove,\n      handlePush: this.handlePush,\n      handlePop: this.handlePop,\n      handleSwap: this.handleSwap,\n      handleMove: this.handleMove,\n      handleInsert: this.handleInsert,\n      handleReplace: this.handleReplace,\n      handleUnshift: this.handleUnshift,\n      handleRemove: this.handleRemove\n    };\n\n    var _a = this.props,\n        component = _a.component,\n        render = _a.render,\n        children = _a.children,\n        name = _a.name,\n        _b = _a.formik,\n        _validate = _b.validate,\n        _validationSchema = _b.validationSchema,\n        restOfFormik = __rest(_b, [\"validate\", \"validationSchema\"]);\n\n    var props = __assign({}, arrayHelpers, {\n      form: restOfFormik,\n      name: name\n    });\n\n    return component ? createElement(component, props) : render ? render(props) : children ? typeof children === 'function' ? children(props) : !isEmptyChildren(children) ? Children.only(children) : null : null;\n  };\n\n  FieldArrayInner.defaultProps = {\n    validateOnChange: true\n  };\n  return FieldArrayInner;\n}(Component);\n\nvar FieldArray =\n/*#__PURE__*/\nconnect(FieldArrayInner);\n\nvar ErrorMessageImpl =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ErrorMessageImpl, _super);\n\n  function ErrorMessageImpl() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ErrorMessageImpl.prototype.shouldComponentUpdate = function (props) {\n    if (getIn(this.props.formik.errors, this.props.name) !== getIn(props.formik.errors, this.props.name) || getIn(this.props.formik.touched, this.props.name) !== getIn(props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  ErrorMessageImpl.prototype.render = function () {\n    var _a = this.props,\n        component = _a.component,\n        formik = _a.formik,\n        render = _a.render,\n        children = _a.children,\n        name = _a.name,\n        rest = __rest(_a, [\"component\", \"formik\", \"render\", \"children\", \"name\"]);\n\n    var touch = getIn(formik.touched, name);\n    var error = getIn(formik.errors, name);\n    return !!touch && !!error ? render ? isFunction(render) ? render(error) : null : children ? isFunction(children) ? children(error) : null : component ? createElement(component, rest, error) : error : null;\n  };\n\n  return ErrorMessageImpl;\n}(Component);\n\nvar ErrorMessage =\n/*#__PURE__*/\nconnect(ErrorMessageImpl);\nexport { useFormik, Formik, yupToFormErrors, validateYupSchema, useField, Field, FastField, Form, withFormik, move, swap, insert, replace, FieldArray, getIn, setIn, setNestedObjectValues, isFunction, isObject, isInteger, isString, isNaN$1 as isNaN, isEmptyChildren, isPromise, getActiveElement, makeCancelable, connect, ErrorMessage, FormikProvider, FormikConsumer, useFormikContext };","map":null,"metadata":{},"sourceType":"module"}